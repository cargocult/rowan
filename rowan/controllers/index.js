/**
 * This module supports the Rowan tree structure of elements in a web
 * application. The tree is made up of 'controllers' that are
 * functions which can be called with a single 'context'
 * argument. Each controller is responsible for either providing the
 * correct response through the 'context.response' object (which is
 * the regular node.js response object), or it may throw a HttpError.
 * Specific versions of the HttpError are provided for different error 
 * cases.
 *
 * With controllers that follow this structure, a web application can be
 * built from reusable components.
 */
var errors = require('../core/errors');

// Include sub-modules.
exports.serve_file = require('./serve_file');

/**
 * A router holds any number of child controllers along with a regular
 * expression that should match their uri. The router tries to match
 * each pattern in turn and calls the corresponding controller for the
 * first one that matches. The router throws a Http404 error if none match.
 */
exports.router = function(routes) {
    var fn = function(context) {
        var path = context.remaining_path;
        for (i in routes) {
            var route = routes[i];
            var match = route.pattern.exec(path)
            if (match) {
                // Add any matched groups.
                if (match.length > 1) {
                    if (!('pattern_groups' in context)) {
                        context.pattern_groups = [];
                    }
                    context.pattern_groups += match.slice(1);
                }

                // Update the unprocessed path.
                context.remaining_path = 
                    path.substr(match.index + match[0].length);

                // Call the view.
                return route.view(context);
            }
        }

        // We found no valid patterns to match the url.
        throw new errors.Http404();
    };
    return fn;
};

/**
 * A method map acts similarly to a router, it can dispatch an incoming
 * request to one of a set of controllers. In this case it maps based on
 * the HTTP method used. To create a controller, specify an object mapping
 * upper case HTTP method names to sub-controllers. The optional second
 * argument can be used to specify a default sub-controller in case the
 * method isn't listed in the map.
 */
exports.method_map = function(map, default_controller) {
    var fn = function(context) {
        var sub_controller = map[context.request.method];
        if (sub_controller) {
            return sub_controller(context);
        } else if (default_controller) {
            return default_controller(context);
        }
        throw new errors.Http405();
    };
    return fn;
};

/**
 * The error handler delegates to a single sub-controller and absorbs any
 * errors it produces, outputting a simple but sane HTML error message.
 * The method can be given a first, optional, argument which is a list of
 * error status codes not to handle.
 */
exports.error_handler = function(unhandled_errors, sub_controller) {
    // Swap arguments if we were only given one.
    if (!sub_controller) {
        sub_controller = unhandled_errors;
        unhandled_errors = null;
    }

    var fn = function(context) {
        try {
            return sub_controller(context);
        } catch (err) {
            var status_code = err.status_code || 500;
            if (!unhandled_errors||unhandled_errors.indexOf(status_code) < 0) {
                var response = context.response;
                var description = err.description || "Server Error";

                response.sendHeader(status_code, {'Content-Type':'text/html'});
                response.sendBody(
                    "<h1>"+status_code.toString()+" "+description+"</h1>"
                );
                response.finish();
            } else {
                throw err;
            }
        };        
    };
    return fn;
};

/**
 * The fallback controller tries each of a list of sub-controllers in
 * turn until one of them does not throw an error. It can be given an
 * optional list of error status values that it will absorb. If this
 * list is given then any other error will be re-thrown
 * immediately. If the list is not given (i.e. the function is called
 * with only one argument) then all errors will be absorbed. If none
 * of the controllers in the fallback succeed, then it will re-throw
 * the error generated by the last controller in the list.
 */
exports.fallback = function(valid_errors, sub_controllers) {
    // Swap arguments if we were only given one.
    if (!sub_controllers) {
        sub_controllers = valid_errors;
        valid_errors = null;
    }
    
    var fn = function(context) {
        for (i in sub_controllers) {
            var sub_controller = sub_controllers[i];
            try {
                return sub_controller(context);
            } catch (err) {
                if (status && valid_errors.indexOf(err.status_code) < 0) {
                    // We have an error that we're not allowed to absorb.
                    throw err;
                }
            }
        }
        // If we get here we received non-fatal errors from all 
        // sub-controllers, so we exit with the last one we saw.
        throw err;
    };   
    return fn;
};

